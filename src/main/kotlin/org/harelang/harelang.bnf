{
    parserClass = "org.harelang.parser.HareParser"
    extends = "com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix = "Hare"
    psiImplClassSuffix = "Impl"
    psiPackage = "org.harelang.parser.psi"
    psiImplPackage = "org.harelang.parser.psi"

    elementTypeHolderClass = "org.harelang.parser.psi.HareTypes"
    elementTypeClass = "org.harelang.parser.psi.HareElementType"
    tokenTypeClass = "org.harelang.parser.psi.HareTokenType"

    psiImplUtilClass="org.harelang.parser.psi.HarePsiImplUtil"
}

translation_unit ::= imports*

imports ::= (use_statement_member_list | use_statement)+
use_statement ::= USE_KW import_alias* import_path (SCOPE "*")? EOS {
pin=1
}
use_statement_member_list ::= USE_KW import_alias* import_path SCOPE LBR member_list RBR EOS
member_list ::= member (COMMA member)*
member ::= IDENTIFIER ASSIGN IDENTIFIER | IDENTIFIER
import_alias ::= IDENTIFIER ASSIGN
import_path ::= IDENTIFIER (SCOPE IDENTIFIER)*

function_definition ::= EXPORT_KW? FN_KW IDENTIFIER function_args type function_block {
pin = 2
}
function_args ::= LP parameter_list RP
function_block ::= LBR expression* RBR
parameter_list ::= parameter COMMA parameter_list* | parameter
parameter ::= IDENTIFIER COLON type
type ::= buildin_type
buildin_type ::= VOID_KW | I8_KW | I16_KW | I32_KW | I64_KW | U8_KW | U16_KW | U32_KW | U64_KW | INT_KW | UINT_KW | SIZE_KW | UINTPTR_KW | CHAR_KW
constant ::= integer_constant | string_const | NULL_KW | TRUE_KW | FALSE_KW | VOID_KW
integer_constant ::= DECIMAL_DIGITS integer_suffix?
integer_suffix ::= "i" | "u" | "z" | "i8" | "i16" | "i32" | "i64" | "u8" | "u16" | "u32" | "u64"
string_const ::= STRING_LITERAL


expression ::= assignment | binding_list | logical_or_expression | if_expression | for_loop

private logical_or_expression ::= logical_xor_expression (LOGICAL_OR logical_xor_expression)*
private logical_xor_expression ::= logical_and_expression (LOGICAL_XOR logical_and_expression)*
private logical_and_expression ::= equality_expression (LOGICAL_AND equality_expression)*
private equality_expression ::= comparison_expression (equality_operator comparison_expression)*
private equality_operator ::= EQUAL | NOT_EQUAL
private comparison_expression ::= inclusive_or_expression (comparison_operator inclusive_or_expression)*
private comparison_operator ::= LESSER_THAN | LARGER_THAN | LESSER_EQUAL | LARGER_EQUAL
private inclusive_or_expression ::= exclusive_or_expression (INCLUSIVE_OR exclusive_or_expression)*
private exclusive_or_expression ::= and_expression (EXCLUSIVE_OR and_expression)*
private and_expression ::= shift_expression (AND shift_expression)*
private shift_expression ::= additive_expression (shift_operator additive_expression)*
private shift_operator ::= LEFT_SHIFT | RIGHT_SHIFT
private additive_expression ::= multiplicative_expression (additive_operator multiplicative_expression)*
private additive_operator ::= ADDS | SUBSTRACTS
private multiplicative_expression ::= cast_expression (multiplicative_operator cast_expression)*
private multiplicative_operator ::= MULTIPLIES | DIVIDES | MODULUS
private cast_expression ::= unary_expression
private unary_expression ::= buildin_expression | compound_expression
private buildin_expression ::= postfix_expression
private postfix_expression ::= nested_expression
private nested_expression ::= plan_expression | LP expression RP
plan_expression ::= IDENTIFIER | constant

compound_expression ::= LBR expression_list RBR
expression_list ::= (expression EOS)+
binding_list ::= STATIC_KW* LET_KW bindings | STATIC_KW* CONST_KW bindings
bindings ::= binding (COMMA binding)*
binding ::= IDENTIFIER ASSIGN expression

assignment ::= object_selector assignment_op expression
assignment_op ::=  ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | MULTIPLIES_ASSIGN | DIVIDES_ASSIGN |
MODULUS_ASSIGN | AND_ASSIGN | OR_ASSIGN | XOR_ASSIGN | LEFT_SHIFT_ASSIGN | RIGHT_SHIFT_ASSIGN | LOGICAL_AND_ASSIGN |
LOGICAL_OR_ASSIGN | LOGICAL_XOR_ASSIGN
object_selector ::= IDENTIFIER | indexing_expression
indexing_expression ::= postfix_expression LB expression RB

if_expression ::= IF_KW conditional_branch | IF_KW conditional_branch ELSE_KW if_expression | IF_KW conditional_branch ELSE_KW expression
conditional_branch ::= LP expression RP expression

for_loop ::= FOR_KW LP for_predicate RP expression
for_predicate ::= binding_list EOS expression EOS expression | binding_list EOS expression | expression EOS expression | expression