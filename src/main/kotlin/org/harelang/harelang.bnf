{
    parserClass = "org.harelang.parser.HareParser"
    extends = "com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix = "Hare"
    psiImplClassSuffix = "Impl"
    psiPackage = "org.harelang.parser.psi"
    psiImplPackage = "org.harelang.parser.psi"

    elementTypeHolderClass = "org.harelang.parser.psi.HareTypes"
    elementTypeClass = "org.harelang.parser.psi.HareElementType"
    tokenTypeClass = "org.harelang.parser.psi.HareTokenType"

    psiImplUtilClass="org.harelang.parser.psi.HarePsiImplUtil"
}

translation_unit ::= imports* declarations*

imports ::= (use_statement_member_list | use_statement)+
use_statement ::= USE_KW import_alias* import_path (SCOPE "*")? EOS {
pin=1
}
use_statement_member_list ::= USE_KW import_alias* import_path SCOPE LBR member_list RBR EOS
member_list ::= member (COMMA member)*
member ::= IDENTIFIER ASSIGN IDENTIFIER | IDENTIFIER
import_alias ::= IDENTIFIER ASSIGN
import_path ::= IDENTIFIER (SCOPE IDENTIFIER)*
identifier_path ::= IDENTIFIER (SCOPE IDENTIFIER)*

declarations ::= (EXPORT_KW? declaration EOS)+
declaration ::= function_declaration | global_declaration | constant_declaration | type_declaration

global_declaration ::= LET_KW global_bindings | CONST_KW global_bindings
global_bindings ::= global_binding (COMMA global_binding)*
global_binding ::= identifier_path COLON type (ASSIGN expression)?

constant_declaration ::= DEF_KW constant_bindings
constant_bindings ::= constant_binding (COMMA constant_binding)*
constant_binding ::= identifier_path COLON type ASSIGN expression

type_declaration ::= TYPE_KW type_bindings
type_bindings ::= type_binding (COMMA type_binding)*
type_binding ::= identifier_path ASSIGN type
function_declaration ::= FN_KW identifier_path prototype (ASSIGN expression)? {
pin=1
}

prototype ::= LP parameter_list? RP type

parameter_list ::= parameters COMMA? DOTDOTDOT?
parameters ::= parameter (COMMA parameter)*
parameter ::= (IDENTIFIER | UNDERSCORE) COLON type
type ::= CONST_KW? BANG? storage_class
storage_class ::= scala_type | struct_union_type | tuple_type | tagged_union_type | slice_array_type | function_type | alias_type | unwrapped_alias | STR_TYPE

scala_type ::= integer_type | floating_type | enum_type  | pointer_type | RUNE_KW | BOOL_TYPE | VALIST_TYPE |  VOID_TYPE

integer_type ::= I8_TYPE | I16_TYPE | I32_TYPE | I64_TYPE | U8_TYPE | U16_TYPE | U32_TYPE | U64_TYPE | INT_TYPE | UINT_TYPE | SIZE_TYPE | UINTPTR_TYPE | CHAR_TYPE

floating_type ::= F32_TYPE | F64_TYPE

enum_type ::= ENUM_KW enum_storage? LBR enum_values RBR
enum_values ::= enum_value (COMMA enum_value)*
enum_value ::= IDENTIFIER ASSIGN expression | IDENTIFIER
enum_storage ::= integer_type | RUNE_KW

pointer_type ::= NULLABLE_KW? MULTIPLIES type

struct_union_type ::= (STRUCT_KW | UNION_KW) LBR struct_union_fields RBR
struct_union_fields ::= struct_union_field (COMMA struct_union_field)*
struct_union_field ::= IDENTIFIER COLON type | struct_union_type | identifier_path

tuple_type ::= LP tuple_types RP
tuple_types ::= type (COMMA type)+

tagged_union_type ::= LP tagged_types RP
tagged_types ::= type (INCLUSIVE_OR type)+

slice_array_type ::= LB (expression | MULTIPLIES | UNDERSCORE)? RB type

function_type ::= FN_KW prototype

alias_type ::= identifier_path
unwrapped_alias ::= DOTDOTDOT identifier_path
constant ::= integer_constant | string_const | NULL_KW | TRUE_KW | FALSE_KW | VOID_KW
integer_constant ::= DECIMAL_DIGITS integer_suffix?
integer_suffix ::= "i" | "u" | "z" | "i8" | "i16" | "i32" | "i64" | "u8" | "u16" | "u32" | "u64"
string_const ::= STRING_LITERAL


expression ::= assignment | binding_list | logical_or_expression | if_expression | for_loop

private logical_or_expression ::= logical_xor_expression (LOGICAL_OR logical_xor_expression)*
private logical_xor_expression ::= logical_and_expression (LOGICAL_XOR logical_and_expression)*
private logical_and_expression ::= equality_expression (LOGICAL_AND equality_expression)*
private equality_expression ::= comparison_expression (equality_operator comparison_expression)*
private equality_operator ::= EQUAL | NOT_EQUAL
private comparison_expression ::= inclusive_or_expression (comparison_operator inclusive_or_expression)*
private comparison_operator ::= LESSER_THAN | LARGER_THAN | LESSER_EQUAL | LARGER_EQUAL
private inclusive_or_expression ::= exclusive_or_expression (INCLUSIVE_OR exclusive_or_expression)*
private exclusive_or_expression ::= and_expression (EXCLUSIVE_OR and_expression)*
private and_expression ::= shift_expression (AND shift_expression)*
private shift_expression ::= additive_expression (shift_operator additive_expression)*
private shift_operator ::= LEFT_SHIFT | RIGHT_SHIFT
private additive_expression ::= multiplicative_expression (additive_operator multiplicative_expression)*
private additive_operator ::= ADDS | SUBSTRACTS
private multiplicative_expression ::= cast_expression (multiplicative_operator cast_expression)*
private multiplicative_operator ::= MULTIPLIES | DIVIDES | MODULUS
private cast_expression ::= unary_expression
private unary_expression ::= assertion_expression | alloc_expression | buildin_expression | compound_expression
private buildin_expression ::= postfix_expression
private postfix_expression ::= nested_expression postfix_op*
private nested_expression ::= plan_expression | LP tuple_items RP | LP expression RP
plan_expression ::= enum_literal | struct_literal | IDENTIFIER | constant | array_literal
array_literal ::= LB array_members RB
array_members ::= expression DOTDOTDOT | expression COMMA array_members | expression

enum_literal ::= IDENTIFIER (SCOPE IDENTIFIER)+

struct_literal ::= STRUCT_KW LBR field_values RBR | IDENTIFIER LBR struct_initializer RBR
field_values ::= field_value (COMMA field_value)*
field_value ::= struct_literal | IDENTIFIER (COLON type)? ASSIGN expression
struct_initializer ::= field_values (COMMA DOTDOTDOT)? | DOTDOTDOT

tuple_items ::= expression (COMMA expression)+
postfix_op ::= field_access_op | slicing_op | indexing_op | call_op | error_propagation_op
indexing_op ::= LB expression RB
slicing_op ::= LB expression? DOTDOT expression? RB
error_propagation_op ::= QUESTION | BANG
field_access_op ::= DOT IDENTIFIER | DOT integer_constant

alloc_expression ::= ALLOC_KW LP (expression COMMA expression | expression DOTDOTDOT | expression) RP | FREE_KW LP expression RP
assertion_expression ::= STATIC_KW? ASSERT_KW LP (expression COMMA string_const | expression) RP | STATIC_KW? ABORT_KW LP string_const? RP
compound_expression ::= LBR expression_list RBR
expression_list ::= (expression EOS)+
binding_list ::= STATIC_KW* LET_KW bindings | STATIC_KW* CONST_KW bindings
bindings ::= binding (COMMA binding)*
binding ::= IDENTIFIER ASSIGN expression

assignment ::= object_selector assignment_op expression
assignment_op ::=  ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | MULTIPLIES_ASSIGN | DIVIDES_ASSIGN |
MODULUS_ASSIGN | AND_ASSIGN | OR_ASSIGN | XOR_ASSIGN | LEFT_SHIFT_ASSIGN | RIGHT_SHIFT_ASSIGN | LOGICAL_AND_ASSIGN |
LOGICAL_OR_ASSIGN | LOGICAL_XOR_ASSIGN
object_selector ::= IDENTIFIER | indexing_expression
indexing_expression ::= postfix_expression LB expression RB

if_expression ::= IF_KW conditional_branch | IF_KW conditional_branch ELSE_KW if_expression | IF_KW conditional_branch ELSE_KW expression
conditional_branch ::= LP expression RP expression

for_loop ::= FOR_KW LP for_predicate RP expression
for_predicate ::= binding_list EOS expression EOS expression | binding_list EOS expression | expression EOS expression | expression

call_op ::= LP argument_list? RP
argument_list ::= expression DOTDOTDOT  | expression COMMA argument_list | expression